// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3932.commands;

import edu.wpi.first.wpilibj.PIDController;

import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc3932.Robot;
import org.usfirst.frc3932.pid.AhrsYawPIDSource;
import org.usfirst.frc3932.pid.DriveSystemRotatePIDOutput;
import java.util.Date;

/**
 *
 */
public class TurnToOrig extends Command {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	private double m_degrees;

	private PIDController controller;

	private boolean notUsingI = true;

	// oscillation period .44 -- Dave's p=.045,i=.007,d=0,f=1.3 for West Palm Beach
	// Mini of working p=.045,i=0,d=.006,0 error 1, buffer 10
	// Mini working with Elias .036,.0025,.00025,0,.1,0 --Take 3 seconds to move 90
	// Big 0.036,.0025,.0025,10,.1,5,Speed=.4
	// Elias .045,0,.040,1.3, error = .1  Works well
	
	private static final double P = .045;
	private static final double I = .00;
	private static final double D = .006;
	private static final double F = 0;
	
	
	private static final double MAX_OUTPUT = 0.3;

	// private double timeout = 0;
	private double m_timeout = 0;

	private static final int MAX_ERROR = 4;
	private int m_errorcounter = 0;
	private Date turnToCreate;
	private Date turnToInit;
	private int count = 0;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public TurnToOrig(double degrees, double timeout) {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		m_degrees = degrees;

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		// Add and F term at point 2 Keith fault

		controller = new PIDController(P, I, D, F, new AhrsYawPIDSource(), new DriveSystemRotatePIDOutput());
		controller.setInputRange(-180, 180);
		controller.setContinuous();
		controller.setAbsoluteTolerance(2);
		controller.setToleranceBuffer(10);
		controller.setOutputRange(1.5, MAX_OUTPUT);
		m_timeout = timeout;
		m_timeout = 60;
		turnToCreate = new Date();
	}

	public TurnToOrig(double degrees) { // Overloaded for 5 second time out
		this(degrees, 5);
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		m_errorcounter = 0;
		Robot.log("Turnto initialized: degrees = " + m_degrees + " Timeout= " + m_timeout + " p:" + P + " i:"
				+ I + " d:" + D + " f:" + F);
		// Robot.driveSystem.resetEncoders();
		controller.enable();
		controller.setSetpoint(m_degrees);
		setTimeout(m_timeout);
		turnToInit = new Date();
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		// if (Math.abs(controller.getError()) < RELATIVELY_CLOSE && notUsingI){
		// controller.setPID(P, I, D);
		// controller.setSetpoint(m_degrees);
		// controller.enable();
		// notUsingI = false;
		// }
		// SmartDashboard.putNumber("Accumulation", controller.);
		// SmartDashboard.putNumber("Error", controller.getError());
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {

		if (Math.abs(controller.getError()) < 1)
			m_errorcounter++;
		else
			m_errorcounter = 0;

		double convTime = (new Date().getTime() - turnToInit.getTime());
		SmartDashboard.putNumber("Time to Turn", convTime);
		Robot.log("TurnTo onTarget:" + controller.onTarget() + " Timeout:" + isTimedOut() + " YAW:"
				+ Robot.ahrs.getYaw() + " Error:" + round2(controller.getError()) + " AvgError:"
				+ round2(controller.getAvgError()) + " ErrorCounter:" + m_errorcounter + " ConvergeTime:" + convTime);
		boolean f1 = controller.onTarget() || (m_errorcounter >= MAX_ERROR) || convTime > m_timeout * 1000;
		boolean f2 = ((m_errorcounter >= MAX_ERROR) || (convTime > m_timeout * 1000)) ;
		boolean f3 = controller.onTarget() || isTimedOut();
		boolean fmaster = f2;
		if(fmaster) {
			if (count > 10) return true;
			controller.disable();
			count++;
		} else {
			count = 0;
		}
		return false;

	}

	// Called once after isFinished returns true
	protected void end() {
		Robot.log("TurnTo finished degrees = " + m_degrees + " timeOut:" + m_timeout + " Yaw:"
				+ Robot.ahrs.getYaw() + " Total Autonomous Time:" + (new Date().getTime() - turnToCreate.getTime()));
		controller.disable();
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		end();
	}

	protected double round2(double d) {
		return Math.round(d * 100) / 100;
	}

}
