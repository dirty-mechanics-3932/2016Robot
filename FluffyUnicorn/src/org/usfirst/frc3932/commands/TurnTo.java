// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc3932.commands;

//import org.usfirst.frc3932.pid.AhrsYawPIDSource;
//import org.usfirst.frc3932.pid.DriveSystemRotatePIDOutput;
import java.util.Date;

import org.usfirst.frc3932.Robot;
import org.usfirst.frc3932.RobotMap;

//import edu.wpi.first.wpilibj.PIDController;

//import edu.wpi.first.wpilibj.PIDOutput;
//import edu.wpi.first.wpilibj.PIDSource;
//import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class TurnTo extends Command {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	private Date m_turnToCreate;
	private Date m_turnToInit;
	private double m_degrees;
	private double m_timeout = 0;
	private RunningAverage avgError;

	private int Samples = 10; // 10 was good for practice  robot
	private double MaxError = .4; // .4 was good practice robot

	private final double miniP[][] = { { 180, .5 }, { 20, .3 }, { 10, .2 }, { 5, .15 }, { 3, .11 }, { 2, .08 },
			{ 1, .06 }, { 0, 0 } };
	private final double compP[][] = { { 180, .4 }, { 20, .3 }, { 10, .25 }, { 5, .22 }, { 3, .20 }, { 2, .19 },
			{ 1, .17 }, { .75, .150 },{ 0, 0 } };
	private double activeP[][] = compP;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public TurnTo(double degrees, double timeout) {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		m_degrees = degrees;
		m_timeout = timeout;
		m_turnToCreate = new Date();

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

	}

	public TurnTo(double degrees) { // Overloaded for 5 second time out
		this(degrees, 5);
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		avgError = new RunningAverage(Samples);
		System.out.printf(
				"********** Turnto init Degrees:%.2f CurrentYaw: %.3f Timeout:%.2f AllowedError:%.2f Samples:%d Version:%s **********%n",
				m_degrees, Robot.ahrs.getYaw(), m_timeout, MaxError, Samples, Robot.ahrs.getFirmwareVersion());
		m_turnToInit = new Date();

	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		double convTime = (new Date().getTime() - m_turnToInit.getTime());
		SmartDashboard.putNumber("Time to Turn", convTime);
		double yaw = Robot.ahrs.getYaw();
		double err = m_degrees - yaw;
		avgError.putNew(err);
		double output = getOutput(err);
		Robot.driveSystem.drivePercent(-output, output);
		double kError = getKError(err);
		System.out.printf(
				"TurnTo YAW:%.3f Error:%.3f AvgError:%.3f kError:%.3f L:%d R:%d ConvergeTime:%.0f Output:%.3f%n", yaw,
				err, getAvgError(), kError, RobotMap.driveSystemLeftFront.getEncPosition(),
				RobotMap.driveSystemRightFront.getEncPosition(), convTime, output);
		// return Math.abs(avgError.getAverage()) < MaxError || (convTime >
		// m_timeout * 1000);
		return Math.abs(kError) < MaxError || (convTime > m_timeout * 1000);
	}

	double getKError(double err) {
		return (Math.abs(getAvgError()) + Math.abs(err)) / 2;
	}

	double getAvgError() {
		return avgError.getAverage();
	}

	// Called once after isFinished returns true
	protected void end() {
		Robot.driveSystem.drivePercent(0, 0);
		System.out.println("TurnTo end degrees:" + m_degrees + " timeOut:" + m_timeout + " Yaw:" + Robot.ahrs.getYaw()
				+ " Total Autonomous Time:" + (new Date().getTime() - m_turnToCreate.getTime()));
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		end();
	}

	protected double getOutput(double error) {
		int i = 0;
		while (i < activeP.length && activeP[i][0] >= Math.abs(error)) {
			i++;
		}
		return error > 0 ? activeP[i - 1][1] : -activeP[i - 1][1];
	}

	protected String bool(boolean val) {
		return val ? "True" : "False";
	}

	protected double round4(double d) {
		return Math.round(d * 10000) / 10000.0;
	}

	// Class for Running Average
	public class RunningAverage {
		private int bufferSize;
		private int lastSample = 0;
		private int numSamples = 0;
		private double[] samples;

		public RunningAverage(int size) {
			samples = new double[size];
			bufferSize = size;
		}

		public void putNew(double d) {
			if (lastSample >= bufferSize) lastSample = 0;
			samples[lastSample] = d;
			lastSample++;
			numSamples++;
			if (numSamples >= bufferSize) numSamples = bufferSize;
		}

		public double getAverage() {
			double sum = 0;
			for (int i = 0; i < numSamples; i++)
				sum += samples[i];
			return sum / numSamples;
		}

		public double variance() {
			double variance = 0;
			double avg = getAverage();
			for (int i = 0; i < numSamples; i++)
				variance += Math.abs(samples[i] - avg);
			return variance / numSamples;
		}

		public boolean isAverageValid() {
			return numSamples >= bufferSize;
		}

		/**
		 * 
		 * @return Returns true if last x averages are the same within a
		 *         specified error.
		 */
		public boolean compareLast(int lastNum, double maxError) {
			if (lastNum > samples.length) lastNum = samples.length;
			double lastSample = samples[samples.length - 1], currentSample;
			for (int i = 1; i <= lastNum; i++) {
				currentSample = samples[samples.length - i];
				if (lastSample - currentSample < maxError) lastSample = currentSample;
				else return false;
			}
			return true;
		}
	}

	class ourTurnPid {

		private double iSum;
		private double Kp, Ki, Kd;
		private double initialTarget = 0;
		private double outMax = .4;
		private double outMin = -.4;
		private double maxError = .25;
		private RunningAverage averageError;
		private RunningAverage averageOutput;
		private RunningAverage averageYaw;
		private double lastError = 0;
		private double lastInput = 0;
		private double lastOut;
		private int numberExecutes = 0;
		private double origKp;

		public ourTurnPid(double Kp, double Ki, double Kd, double MaxError, int numSamples) {
			this.Ki = Ki;
			this.Kp = Kp;
			this.Kd = Kd;
			this.origKp = Kp;
			this.maxError = MaxError;
			averageError = new RunningAverage(numSamples);
			averageOutput = new RunningAverage(numSamples);
			averageYaw = new RunningAverage(numSamples);
		}

		public void setTarget(double target) {
			initialTarget = target;
		}

		public void disable() {
			Robot.driveSystem.drivePercent(0, 0);
		}

		public boolean onTarget() {
			double err = (Math.abs(averageError.getAverage()) + Math.abs(lastError)) / 2;
			return (err < maxError);
		}

		public boolean onTarget1() {
			double err = (Math.abs(averageError.getAverage()) + Math.abs(lastError)) / 2;
			return (err < maxError);

		}

		public boolean onTarget2() {
			if (averageError.isAverageValid()) {
				double err = (Math.abs(averageError.getAverage()) + Math.abs(lastError)) / 2;
				if (err < maxError) return true;
			} else {
				if (numberExecutes > 2 && Math.abs(averageError.getAverage()) < maxError) return true;
			}
			return false;

		}

		public double getAvgError() {
			return averageError.getAverage();
		}

		public double getAvgOutput() {
			return averageOutput.getAverage();
		}

		public double getAvgYaw() {
			return averageYaw.getAverage();
		}

		public double getError() {
			return lastError;
		}

		public double lastOuput() {
			return lastOut;
		}

		public void execute() {
			double input = Robot.ahrs.getYaw();
			averageYaw.putNew(input);

			// Use current value, no derivative action on first sample
			if (lastInput == 0) lastInput = input;

			double target = initialTarget;

			double outputMax = outMax;
			double outputMin = outMin;

			double error = target - input;
			lastError = error;
			averageError.putNew(lastError);

			iSum += Ki * error;

			if (iSum > outputMax) iSum = outputMax;
			else if (iSum < outputMin) iSum = outputMin;

			double inputDelta = input - lastInput;

			double output = (Kp * error) + iSum - (Kd * inputDelta);

			if (output > outputMax) output = outputMax;
			else if (output < outputMin) output = outputMin;

			double cap = .15;
			if (Math.abs(output) < cap) {
				// output *= 2; // Changed from 1.8 Keith 4/8
				// if (averageYaw.compareLast(4, 0.01))
				// cap += 0.1;
				output = output < 0 ? -cap : cap;
				System.out.println("Updated Output variance:" + averageError.variance());
			}

			Robot.driveSystem.drivePercent(-output, output);
			averageOutput.putNew(output);
			lastOut = output;
			lastInput = input;
			numberExecutes++;
		}
	}
}
